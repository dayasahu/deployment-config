# ===================================================================
# Kubernetes Dashboard UI Setup
# ===================================================================

# Official Documentation:-
# https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/
# https://github.com/kubernetes/dashboard/blob/master/docs/user/access-control/creating-sample-user.md

# --- Installation using Helm (requires Chocolatey on Windows) ---

# 1. Install Chocolatey (Package Manager for Windows)
# Open PowerShell as Administrator and run:
Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))

# 2. Install Helm using Chocolatey
choco install kubernetes-helm

# 3. Add the Kubernetes Dashboard Helm repository
helm repo add kubernetes-dashboard https://kubernetes.github.io/dashboard/

# 4. Install/Upgrade the dashboard in its own namespace
helm upgrade --install kubernetes-dashboard kubernetes-dashboard/kubernetes-dashboard --create-namespace --namespace kubernetes-dashboard

# --- Accessing the Dashboard ---

# 1. Port-forward to the dashboard's proxy service
kubectl -n kubernetes-dashboard port-forward svc/kubernetes-dashboard-kong-proxy 8443:443

# 2. Create a sample admin user (if not already done, see official docs for the YAML)
# The YAML for this is typically in the official documentation link above.
# Example: kubectl apply -f recommended.yaml
# Example: kubectl apply -f dashboard-adminuser.yaml

# 3. Get the authentication token for the 'admin-user'
# Note: This assumes you have created a ServiceAccount named 'admin-user'.
kubectl -n kubernetes-dashboard create token admin-user

# Alternative way to get token from the secret (older method)
# kubectl get secret admin-user -n kubernetes-dashboard -o jsonpath="{.data.token}" | %{ [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($_)) }

# Now, navigate to https://localhost:8443 and use the generated token to log in.


# ===================================================================
# Local Development with Docker & Docker Compose
# ===================================================================

# --- Building Images ---
# Build a specific service's Docker image
docker build . -t dayasahu6077/employee:v25dec
docker build . -t dayasahu6077/department:v25dec
docker build . -t dayasahu6077/configserver:v25dec

# --- Pushing Images to Docker Hub ---
docker push dayasahu6077/department:v2

# --- Running Containers Manually ---

# Run config server, mapping a local config folder into the container
# The '-v' flag mounts the local directory 'D:\1_GITHUB\microservices-training\config\props'
# to the '/config' directory inside the container.
docker run -d --name configserver -p 8071:8071 -v D:/1_GITHUB/microservices-training/config/props:/config dayasahu6077/configserver:v26dec

# Run employee service, linking it to the running config server container
# The '--link' flag is a legacy feature; modern approach is to use a shared docker network.
docker run -d --name employee --link configserver -p 8081:8080 -e SPRING_CONFIG_IMPORT=configserver:http://configserver:8071 -e SPRING_PROFILES_ACTIVE=dev -e SPRING_APPLICATION_NAME=employee dayasahu6077/employee:v26dec2am

# --- Running with Docker Compose ---

# Start all services defined in the docker-compose.yml file in detached mode
docker-compose up -d

# Example docker-compose.yml structure:
#
# version: "3.9"
# services:
#   configserver:
#     image: dayasahu6077/configserver:v26dec
#     ports:
#       - "8071:8071"
#     volumes:
#       - D:/1_GITHUB/microservices-training/config/props:/config
#     healthcheck:
#       test: ["CMD-SHELL", "curl -f http://localhost:8071/actuator/health || exit 1"]
#       interval: 10s
#       timeout: 5s
#       retries: 10
#       start_period: 10s
#     networks:
#       - dsnetwork
#
#   employee:
#    image: dayasahu6077/employee:v26dec2am
#    ports:
#     - "8081:8080"
#    environment:
#     - SPRING_CONFIG_IMPORT=configserver:http://configserver:8071
#     - SPRING_PROFILES_ACTIVE=dev
#     - SPRING_APPLICATION_NAME=employee
#    depends_on:
#     configserver:
#       condition: service_healthy
#    networks:
#     - dsnetwork
#
# networks:
#   dsnetwork:
#     driver: bridge


# ===================================================================
# Manual Kubernetes Management (kubectl)
# ===================================================================

# --- Basic Commands ---
kubectl get services
kubectl get deployments
kubectl get replicaset
kubectl get pods

# --- Applying Configurations ---

# Apply all YAML files in a directory
kubectl apply -f configserver/

# Apply configurations using Kustomize from a specific overlay
# This builds the final YAML from the base + overlay and applies it.
kubectl apply -k services/employee/overlays/dev

# --- Managing Deployments ---

# Delete a deployment
kubectl delete deployment configserver

# Trigger a rolling restart of a deployment's pods
kubectl rollout restart deployment configserver
kubectl rollout restart deployment employee


# ===================================================================
# Tekton CI/CD Pipeline Setup
# ===================================================================

# --- Installation ---

# 1. Install Tekton Pipelines
kubectl apply -f https://storage.googleapis.com/tekton-releases/pipeline/latest/release.yaml

# 2. Install Tekton Dashboard (for UI)
kubectl apply -f https://storage.googleapis.com/tekton-releases/dashboard/latest/release.yaml

# 3. Install Tekton Triggers (for auto-triggering builds from webhooks)
kubectl apply -f https://storage.googleapis.com/tekton-releases/triggers/latest/release.yaml


# --- Authentication Setup ---

# 1. Create a secret for Docker Hub to allow Tekton to push images
# This should be created in the 'tekton-pipelines' namespace.
# Use a Personal Access Token (PAT) for the password.
kubectl create secret docker-registry dockerhub-secret \
  --docker-username=dayasahu6077 \
  --docker-password=YOUR_DOCKER_HUB_PAT \
  --docker-email=dayashankarsahuch@gmail.com \
  -n tekton-pipelines

# 2. Create a secret for a private GitHub repo (if needed for cloning)
# The token needs 'repo' scope.
kubectl create secret generic github-token \
  --from-literal=token=YOUR_GITHUB_PAT \
  -n tekton-pipelines

# 3. Create a secret for GHCR (GitHub Container Registry)
# The token needs 'write:packages' scope.
kubectl create secret docker-registry ghcr-pull-secret \
  --docker-server=ghcr.io \
  --docker-username=dayasahu6077 \
  --docker-password=YOUR_GITHUB_PAT \
  --docker-email=you@example.com \
  -n tekton-pipelines

# 4. Verify secret creation
kubectl get secret dockerhub-secret -n tekton-pipelines -o jsonpath='{.data.\.dockerconfigjson}' | base64 -d

# 5. Create ServiceAccounts and link them to the secrets
# This allows the PipelineRun to use the credentials.
kubectl apply -n tekton-pipelines -f tekton/tekton-ci-sa.yaml


# --- Creating Tekton Resources ---

# Apply Tasks and the Pipeline definition to the 'tekton-pipelines' namespace
kubectl apply -n tekton-pipelines -f tekton/task-git-clone.yaml
kubectl apply -n tekton-pipelines -f tekton/task-maven-build.yaml
kubectl apply -n tekton-pipelines -f tekton/task-docker-build-push.yaml
kubectl apply -n tekton-pipelines -f tekton/task-kubectl-deploy.yaml
kubectl apply -n tekton-pipelines -f tekton/pipeline-employee-ci.yaml

# --- Running the Pipeline ---

# Manually trigger a pipeline run
kubectl create -n tekton-pipelines -f tekton/pipelinerun-employee-ci.yaml


# --- Verification and Troubleshooting ---

# Check the status of all Tekton resources
kubectl get task,pipeline,pipelinerun,secret -n tekton-pipelines

# Describe a specific TaskRun to see detailed status and events
kubectl describe taskrun <taskrun-name> -n tekton-pipelines

# Common Error: PodAdmissionFailed
# This can happen if the namespace has restrictive security policies.
# The following command relaxes the policy for the 'tekton-pipelines' namespace.
kubectl label namespace tekton-pipelines pod-security.kubernetes.io/enforce=privileged --overwrite

# Common Error: ImagePullBackOff for git-init
# This means the cluster can't pull the default git-init image.
# Often caused by registry auth issues (e.g., for GHCR) or network policies.
# Ensure the ServiceAccount for the TaskRun has the correct imagePullSecrets.

# Common Error: UNAUTHORIZED push to Docker Hub
# This means the 'dockerhub-secret' is missing, incorrect, or not linked to the ServiceAccount.
# Re-create the secret with a valid PAT and ensure the ServiceAccount uses it.


# --- Cleaning Up Tekton Resources ---
kubectl delete pipelinerun -n tekton-pipelines --all
kubectl delete pipeline employee-ci -n tekton-pipelines
kubectl delete task maven-build -n tekton-pipelines
# ... and so on for other tasks


# --- Auto-triggering with Tekton Triggers ---

# 1. Apply Trigger resources
kubectl apply -n tekton-pipelines -f tekton/triggerbinding-github.yaml
kubectl apply -n tekton-pipelines -f tekton/triggertemplate-employee.yaml
kubectl apply -n tekton-pipelines -f tekton/eventlistener-github.yaml

# 2. Expose the EventListener service to receive webhooks from GitHub
# Option A: Port-forward for local testing
kubectl port-forward svc/el-github-listener 8080:8080 -n tekton-pipelines

# Option B: Expose via a NodePort service for external access
kubectl expose svc el-github-listener --type=NodePort --name=github-webhook -n tekton-pipelines
# Then find your node's IP and the assigned port to build the webhook URL.


# --- RBAC for Deployment Task ---

# To allow Tekton to deploy to the 'default' namespace, the ServiceAccount needs permissions.
kubectl apply -f tekton/tekton-deploy-sa.yaml
kubectl apply -f tekton/tekton-deploy-rbac.yaml
kubectl apply -f tekton/tekton-ci-deploy-rbac.yaml

# Verify the ServiceAccount's permissions
kubectl auth can-i update deployment/employee --as=system:serviceaccount:tekton-pipelines:tekton-ci-sa -n default


# ===================================================================
# Monitoring with Prometheus & Grafana
# ===================================================================

# --- Setup using Helm ---

# 1. Add the Prometheus Community Helm repository
helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
helm repo update

# 2. Install the kube-prometheus-stack
# This chart includes Prometheus, Grafana, Alertmanager, and various exporters.
helm install prometheus prometheus-community/kube-prometheus-stack -n monitoring --create-namespace

# --- Accessing Grafana ---

# 1. Port-forward to the Grafana service
kubectl port-forward svc/prometheus-grafana 3000:80 -n monitoring

# 2. Log in to Grafana
# URL: http://localhost:3000
# Default username: admin
# To get the default password, run:
kubectl get secret prometheus-grafana -n monitoring -o jsonpath="{.data.admin-password}" | base64 --decode

# Once logged in, you can add the Prometheus data source (it's usually pre-configured)
# and import dashboards. Search for Spring Boot / Micrometer dashboards by ID (e.g., 4701, 12900).

